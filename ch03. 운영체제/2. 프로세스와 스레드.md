# 프로세스와 스레드
## 프로세스의 종류
- 포그라운드 프로세스: 사용자가 볼 수 있는 곳에서 실행되는 프로세스
- 백그라운드 프로세스: 사용자가 보지 못하는 곳에서 실행되는 프로세스
  - 데몬/서비스 프로세스: 주어진 작업만을 수행하는 백그라운드 프로세스

## 사용자 영역에서의 메모리 배치
![](https://lh4.googleusercontent.com/proxy/TRLpOmIXbQEr9WH4By3hr__2cBYkXKRqE12QwQEQg9Hi0yrqFp93-e7ZlGSgErVztnre717GKI7KC_x1V_gQ1QHd--dw2JjcADVnSaVGgw)

- 코드 영역: 실행 가능한 명령어가 저장되는 공간
- 데이터 영역: 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간 (정적변수나 전역변수가 저장)
- 힙 영역: 개발자가 직접 할당 가능한 저장 공간 (동적 메모리 할당)
  - 메모리 누수(memory leak): 할당된 메모리를 해제하지 않아 사용하지 않는 메모리가 계속 남아있는 현상
  - 가비지 컬렉션(garbage collection): 사용하지 않는 메모리를 자동으로 해제하는 기능
- 스택 영역: 함수 호출 시 생성되는 지역 변수, 매개 변수, 함수 복귀 주소 등이 저장되는 공간
  - 스택 트레이스: 함수 호출의 역순으로 쌓인 함수들의 목록

### Why? 사용자 영역에서의 메모리 배치를 나눈 것인가?
- 효율성 → 코드, 전역 변수, 힙, 스택을 분리해 관리 효율 극대화
- 안정성 → 잘못된 메모리 접근으로부터 다른 영역 보호
- 보안성 → 커널 영역과 사용자 영역을 분리하여 시스템 보호
- 프로세스 독립성 → 프로세스 간 메모리 간섭 방지
- 참고자료: https://www.geeksforgeeks.org/c/memory-layout-of-c-program/

## PCB와 문맥 교환
- PCB(Process Control Block): 프로세스의 상태와 정보를 저장하는 자료구조
  - 프로세스 ID, 프로그램 카운터, CPU 레지스터, 메모리 관리 정보, 입출력 상태 정보 등
  - 운영체제가 프로세스를 관리하는 데 필요한 모든 정보 포함
  - PCB 구조체의 예시
  ![](https://postfiles.pstatic.net/20160429_171/eldkrpdla121_14619047144741Sxu1_PNG/1.png?type=w2)
  - PCB들은 프로세스 테이블의 형태로 저장되기도 함
  ![](https://csnote.net/assets/img/os/process_table.png)
- 문맥 교환: 기존 프로세스의 문맥을 PCB에 백업하고, 새로운 프로세스 문맥을 PCB로부터 복구하여 새로운 프로세스를 실행하는 과정
  - 문맥 교환 과정
  ![](https://csnote.net/assets/img/os/context_switch.png)
  - 타이머 인터럽트: 프로세스의 CPU 사용 시간을 제한하기 위해 설정된 타이머가 만료되었을 때 발생하는 인터럽트
  
### Why? PCB와 문맥 교환이 필요한가?
| 항목           | 필요 이유                | 결과                    |
| ------------ | -------------------- | --------------------- |
| **PCB**      | 프로세스 상태 저장 및 관리      | 멀티프로세스 환경에서 안정성 보장    |
| **문맥 교환**    | 여러 프로세스가 CPU를 번갈아 사용 | 멀티태스킹 및 자원 활용 최적화     |
| **두 개념의 관계** | PCB를 통해 문맥 교환 가능     | PCB 없이는 프로세스 상태 복원 불가 |


## 프로세스의 상태
![](https://csnote.net/assets/img/os/process_state.png)
- 생성 상태 (new)
  - 프로세스를 생성 중인 상태
  - 메모리에 적재되어 PCB를 할당받은 상태
  - 생성 상태를 거져 실행할 준비가 완료된 프로세스는 준비 상태가 되어 CPU의 할당을 기다림
- 준비 상태 (ready)
  - CPU 할당 받을 수 있지만, 차례를 기다리는 상태
  - 준비 상태인 프로세스가 CPU를 할당받으면 실행 상태가 됨
  - **디스패치**: 준비 상태에서 실행 상태로 전환하는 과정
- 실행 상태 (running)
  - CPU를 할당받아 명령어를 실행하는 상태
  - 일정 시간 동안만 CPU를 사용할 수 있음
  - 할당된 시간이 끝나, 타이머 인터럽트가 발생하면 다시 준비 상태가 됨
  - 실행 도중 입출력장치를 사용하여 입출력장치의 작업이 끝날 때까지 기다려야 하면 대기 상태가 됨
- 대기 상태 (blocked)
  - 바로 실행이 불가능한 조건에 놓이는 경우의 상태
    - 프로세스가 입출력 작업을 요청
    - 바로 확보할 수 없는 자원을 요청
  - 실행 가능한 상태가 되면 다시 준비 상태가 되어 CPU 할당을 기다림
- 종료 상태 (terminated)
  - 프로세스가 종료된 상태를 의미
  - 운영체제는 PCB와 프로세스가 사용한 메모리를 정리함
### 블로킹 입출력과 논블로킹 입출력
- 블로킹 입출력 (blocking I/O)
  - ![](https://csnote.net/assets/img/os/blocking_io.png)
  - 입출력 작업이 완료될 때까지 프로세스가 대기 상태에 머무르는 방식
  - CPU 자원을 효율적으로 사용하지 못할 수 있음
- 논블로킹 입출력 (non-blocking I/O)
  - ![](https://csnote.net/assets/img/os/nonblocking_io.png)
  - 입출력 작업이 완료되지 않아도 프로세스가 계속 실행될 수 있는 방식
  - CPU 자원을 더 효율적으로 사용할 수 있음
- 블로킹, 논블로킹 입출력의 비교

| 항목        | 블로킹 입출력                    | 논블로킹 입출력                 |
| ----------- | ------------------------------- | ------------------------------- |
| **정의**    | 입출력 작업 완료까지 대기          | 입출력 작업 완료 여부와 상관없이 실행 계속 |
| **장점**    | 구현이 간단하고 직관적            | CPU 자원 활용 극대화             |
| **단점**    | CPU 자원 낭비 가능성              | 구현 복잡성 증가                 |
| **사용 사례** | 단순한 입출력 작업에 적합         | 고성능 서버, 실시간 시스템에 적합    |


# 멀티프로세스와 멀티스레드

# 프로세스간 통신

# 참고자료
- https://csnote.net/
- https://blog.naver.com/eldkrpdla121/220696668120
- https://www.tcpschool.com/c/c_memory_structure

admin 페이지
관리자 로그인 기능 구현
방문자 시각화
화요일 오전까지