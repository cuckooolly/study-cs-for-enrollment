# 응용 계층 - HTTP의 응용
## 쿠키

### 쿠키의 개념
- 서버에서 생성되어 클라이언트 측에 저장되는 데이터
- 상태를 유지하지 않는 HTTP의 특성을 보완하기 위한 수단<br>

![](https://developer.mozilla.org/shared-assets/images/diagrams/http/cookies/cookie-basic-example.png)

### Set-Cookie와 Cookie 헤더
- 클라이언트가 서버에 요청을 보낼 때, 서버는 Set-Cookie 헤더를 통해 쿠키를 생성하여 응답
    ```plaintext
    HTTP/1.0 200 OK
    Content-type: text/html
    Set-Cookie: yummy_cookie=choco # 쿠키 생성
    Set-Cookie: tasty_cookie=strawberry # 쿠키 생성
    
    [page content]
    ```
- 클라이언트는 이후 동일한 서버에 요청을 보낼 때, Cookie 헤더를 통해 저장된 쿠키를 함께 전송
    ```plaintext
    GET /sample_page.html HTTP/1.1
    Host: www.example.org
    Cookie: yummy_cookie=choco; tasty_cookie=strawberry # 저장된 쿠키 전송
    ```
- 서버는 클라이언트가 보낸 쿠키를 확인하여 상태를 유지하거나 사용자 식별 등에 활용

### 쿠키의 유효기간
- 세션 쿠키 (Expires, Max-Age 속성이 없는 쿠키)는 현재 세션이 끝날 때 삭제
  - 브라우저는 "현재 세션"이 끝나는 시점을 정의, 일반적으로 브라우저를 닫을 때 삭제됨
  - 어떤 브라우저들은 재시작할 때 세션을 복원해 세션 쿠키가 무기한 존재할 수 있도록 함
- 유효기간이 있는 쿠키는 Expires 또는 Max-Age 속성을 통해 설정
  - Expires: 특정 날짜와 시간에 쿠키가 만료됨
  - Max-Age: 쿠키가 생성된 후 몇 초 후에 만료될지 지정
  ```plaintext
  Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
  ```
### Secure과 HttpOnly 쿠키
- Secure 속성: 쿠키가 HTTPS 연결을 통해서만 전송되도록 지정
- HttpOnly 속성: 자바스크립트와 같은 클라이언트 측 스크립트에서 쿠키에 접근하지 못하도록 지정하여 XSS 공격으로부터 보호
```plaintext
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
```

### 웹 스토리지: 로컬 스토리지와 세션 스토리지
- 로컬 스토리지: 도메인별로 데이터를 영구적으로 저장, 브라우저를 닫아도 데이터 유지
- 세션 스토리지: 도메인별로 데이터를 세션 단위로 저장, 브라우저 탭을 닫으면 데이터 삭제

## 캐시

### 캐시의 개념
- 이전에 가져온 리소스를 재사용하여 웹 사이트와 애플리케이션의 성능을 향상시키는 기술
- 레이턴시(지연 시간)와 네트워크 트래픽을 줄여 리소스를 보여주는 시간을 단축

### 캐시의 종류
- **사설 캐시 (Private Cache)**: 단일 사용자 전용 캐시 (예: 웹 브라우저의 로컬 캐시). 뒤로 가기, 오프라인 브라우징 등에 활용.
- **공유 캐시 (Shared Cache)**: 여러 사용자가 재사용할 수 있도록 응답을 저장하는 캐시 (예: ISP의 프록시 캐시, CDN).

### 캐시 동작의 대상
- 일반적으로 **GET** 요청에 대한 **200 (OK)** 응답이 주요 대상
- 그 외 영구 리다이렉트(301), 오류 응답(404), 부분 응답(206) 등도 캐싱 가능

### 캐시 제어 (Cache-Control)
- `Cache-Control` 헤더를 통해 캐싱 정책을 정의 (요청과 응답 모두 사용 가능)
    ```plaintext
    Cache-Control: no-store         # 캐시하지 않음 (매번 서버에서 다운로드)
    Cache-Control: no-cache         # 캐시 저장 가능하나, 사용 전 항상 서버에 유효성 검사(재검증) 필수
    Cache-Control: private          # 브라우저 같은 사설 캐시에만 저장 허용
    Cache-Control: public           # 공유 캐시에도 저장 허용
    Cache-Control: max-age=3153600  # 리소스가 유효한(fresh) 최대 시간(초) 설정
    Cache-Control: must-revalidate  # 만료된 리소스 사용 전 반드시 서버 검증 수행
    ```

### 유효성(Freshness)과 검증(Validation)
- **유효성(Freshness)**: 리소스가 만료 시간(`max-age` 또는 `Expires`) 이전이면 '유효(fresh)'한 상태로 간주하여 서버 확인 없이 즉시 사용.
- **검증(Validation)**: 리소스가 만료(stale)되었을 때, 여전히 유효한지 서버에 확인하는 과정.
  - **ETag / If-None-Match**: 리소스의 고유 식별자(해시 등)를 비교 (강한 검증).
  - **Last-Modified / If-Modified-Since**: 리소스의 최종 수정 시각을 비교 (약한 검증).
- 서버 검증 결과 리소스가 변경되지 않았다면 **304 Not Modified** 응답을 보내 대역폭을 절약하고 캐시된 데이터를 계속 사용하게 함.

### 상황에 따른 응답 (Vary)
- `Vary` 헤더는 캐시된 응답을 어떤 요청 헤더 기준으로 구분하여 제공할지 결정
- 예: 접속한 기기(모바일/데스크탑)나 압축 지원 여부에 따라 다른 캐시를 제공해야 할 때 사용
    ```plaintext
    Vary: User-Agent       # User-Agent 값에 따라 다른 응답을 캐싱 및 제공
    Vary: Accept-Encoding  # 압축 방식에 따라 다른 응답을 캐싱 및 제공
    ```

## 콘텐츠 협상

### 콘텐츠 협상의 개념
- 동일한 URI에서 리소스의 서로 다른 버전(문서의 언어, 이미지 포맷, 인코딩 방식 등)을 제공하기 위해 사용하는 메커니즘
- 사용자 에이전트(브라우저)가 사용자에게 가장 적절한 리소스 버전을 명시하고 서버가 이를 반영하여 제공
<br>

![](https://developer.mozilla.org/ko/docs/Web/HTTP/Guides/Content_negotiation/httpnego.png)

### 협상 방식
- **서버 주도 협상 (Server-driven Negotiation)**
  - 가장 일반적인 방식. 클라이언트가 HTTP 헤더(`Accept-*`)를 통해 선호 사항을 보내면 서버가 적절한 버전을 선택
  - 단점: 서버가 브라우저의 모든 상태를 알 수 없음, 헤더 정보로 인한 사생활 침해(Fingerprinting), 캐시 효율 저하 가능성
  
  <br>
  
  ![](https://developer.mozilla.org/ko/docs/Web/HTTP/Guides/Content_negotiation/httpnegoserver.png)
- **에이전트 주도 협상 (Agent-driven Negotiation)**
  - 서버가 모호한 요청에 대해 선택 가능한 리소스 목록(300 Multiple Choices 등)을 보내면 클라이언트가 직접 선택
  - 단점: 표준화된 형식이 부족하여 자동화가 어렵고, 추가 요청이 필요하여 느려질 수 있음 (주로 스크립트 기반 리다이렉션으로 대체 사용)
  
  <br>
  
  ![](https://developer.mozilla.org/ko/docs/Web/HTTP/Guides/Content_negotiation/httpnego3.png)

### 주요 헤더 (서버 주도 협상)
- 클라이언트가 서버에 선호 사항을 알리기 위해 전송하는 헤더들 (품질 인자 `q`를 통해 우선순위 지정 가능)
    ```plaintext
    Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8
    Accept-Language: ko-KR, ko;q=0.9, en-US;q=0.8
    Accept-Encoding: gzip, deflate, br
    User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) ...
    ```

### Vary 응답 헤더와 캐시
- 서버 주도 협상 시, 캐시 서버가 올바른 응답을 제공하기 위해 필요한 헤더
- `Vary` 헤더에 명시된 요청 헤더 값이 다르면, 캐시된 응답을 재사용하지 않고 서버에 새로운 요청을 보내거나 별도로 캐싱함
    ```plaintext
    Vary: Accept-Language, User-Agent
    # Accept-Language나 User-Agent가 다른 요청에는 다른 캐시를 제공해야 함을 명시
    ```

## 보안: SSL/TLS와 HTTPS

### SSL의 개념
- **SSL (Secure Socket Layer)**: TCP/IP(전송/라우팅)와 HTTP(애플리케이션) 사이에서 실행되는 프로토콜
- 통신 양 당사자(클라이언트와 서버) 간의 암호화된 보안 연결을 수립하여 도청자가 데이터를 읽거나 수정하지 못하도록 보호

### 핸드쉐이크의 종류
- **One-way SSL**: 클라이언트가 서버의 신원만 검증 (일반적인 웹 브라우징)
- **Two-way SSL (Mutual SSL)**: 클라이언트와 서버가 서로의 신원을 양방향으로 검증

### 핸드쉐이크 상세 단계 (SSL Handshake)

- **1. Client Hello**: 클라이언트가 서버에 연결 요청. 지원하는 TLS 버전, 암호화 알고리즘(Cipher Suite), 랜덤 값 전송
- **2. Server Hello**: 서버가 클라이언트의 제안 중 하나를 선택하여 응답 (선택된 Cipher Suite, 세션 ID 등)
- **3. Server Certificate Chain**: 서버가 신뢰성을 증명하기 위해 SSL 인증서와 체인을 전송
- **4. Client Key Exchange**: 클라이언트가 세션 키 생성을 위한 Pre-master secret을 서버에 전송 (서버 공개키로 암호화)
- **5. Change Cipher Spec & Finished**: 양측이 이후 통신을 암호화하겠다고 알리고, 핸드쉐이크 무결성을 검증

<br>

![](https://miro.medium.com/v2/resize:fit:1100/format:webp/1*WUm6FZBkq6dGzCYdODr6Nw.jpeg)

### 키 교환 알고리즘 비교
- **RSA 방식**
  - 인증과 키 교환이 통합된 형태. 클라이언트가 Pre-master key를 서버의 공개키로 암호화하여 전송.
  - 서버가 자신의 개인키로 이를 복호화할 수 있다면 인증과 키 교환이 동시에 성공.
- **Diffie-Hellman (DH) 방식**
  - 키 교환과 인증이 분리됨. 서버 서명(RSA/ECDSA)으로 인증 수행.
  - 양측이 파라미터를 교환하고 수학적 연산을 통해 세션 키를 각자 독립적으로 생성 (직접 전송 X).

### 주요 로그 식별
- 로그를 통해 협상된 TLS 버전, Cipher Suite, 그리고 인증서 신뢰 여부를 확인할 수 있음
- **Two-way SSL**의 경우 서버가 클라이언트에게 인증서를 요구하는 `CertificateRequest` 메시지가 로그에 나타남

    ```plaintext
    # Client Hello: 클라이언트가 제안하는 버전 및 알고리즘
    ClientHello: TLSv1.2, Cipher Suites: [TLS_ECDHE_RSA_WITH_AES...]
    
    # Server Hello: 서버가 선택한 설정
    ServerHello: Selected Protocol: TLSv1.2, Cipher: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
    
    # 인증서 체인 검증 성공 시
    Consuming server Certificate chain..
    Found trusted certificate: CN=[www.example.com](https://www.example.com)
    
    # Two-way SSL에서만 나타나는 클라이언트 인증 요청
    CertificateRequest: Client Certificate Type: rsa_sign...
    ```

## SSL과 TLS의 차이점
- SSL은 초기 버전으로 더 이상 사용되지 않으며, TLS가 그 후속 프로토콜로 자리잡음
- TLS는 SSL에 비해 향상된 보안 기능과 효율성을 제공
- TLS 1.0, 1.1, 1.2, 1.3 등 여러 버전이 있으며, 최신 버전일수록 더 강력한 보안과 성능을 제공

### 기술적 차이점 상세

| 구분                  | SSL (Secure Sockets Layer)          | TLS (Transport Layer Security)                                  |
|:--------------------|:------------------------------------|:----------------------------------------------------------------|
| **기반 및 표준**         | Netscape사 개발 (비표준), 웹 브라우저용         | **IETF 표준 (RFC)**, SSL 3.0 기반으로 개발                              |
| **메시지 인증 (MAC)**    | 구형 MAC 알고리즘 사용 (보안 취약)              | **HMAC** (Hash-based MAC) 표준 사용 (무결성 강화)                        |
| **의사 난수 생성 (PRF)**  | MD5와 SHA-1을 단순 조합하여 난수 생성           | **HMAC 기반의 의사 난수 함수 (PRF)** 사용 (데이터 확장 및 보안성 강화)                |
| **핸드쉐이크 검증**        | 핸드쉐이크 완료 메시지 생성 방식이 단순함             | PRF와 HMAC을 사용하여 **전체 핸드쉐이크 내용의 무결성**을 검증                        |
| **암호화 알고리즘**        | 보안 취약점이 발견된 구형 알고리즘 지원 (RC4, DES 등) | 취약한 알고리즘 제거, 최신 알고리즘(AES-GCM, ChaCha20) 및 **AEAD** 지원 (TLS 1.3) |
| **경고 프로토콜 (Alert)** | 경고 메시지가 단순하고 모호함                    | 경고 메시지가 **상세화 및 표준화**되어 문제 원인 파악 용이                             |
| **지원 프로토콜 버전**      | 1.0, 2.0, 3.0 (모두 보안 문제로 사용 중단됨)    | 1.0, 1.1, 1.2, **1.3** (현재 1.2 이상 권장)                           |

# 참고자료
- https://csnote.net/
- https://developer.mozilla.org/ko/docs/Web/HTTP/Guides/Cookies
- https://developer.mozilla.org/ko/docs/Web/HTTP/Guides/Caching
- https://developer.mozilla.org/ko/docs/Web/HTTP/Guides/Content_negotiation
- https://nipunadilhara.medium.com/analyzing-ssl-handshake-logs-512b1e6eee75
