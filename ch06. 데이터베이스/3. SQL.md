# SQL
## 데이터 정의 언어(DDL)

| 종류       | 설명                      |
|----------|-------------------------|
| CREATE   | 데이터베이스 혹은 데이터베이스 객체 생성  |
| ALTER    | 데이터베이스 객체 갱신            |
| DROP     | 데이터베이스 객체 삭제            |
| TRUNCATE | 테이블 구조를 유지한 채 모든 레코드 삭제 |

### CREATE

#### 기본 문법
- 데이터베이스 생성
```SQL
CREATE DATABASE database_name;
```

- 데이터베이스 사용
```SQL
USE database_name;
```

- 테이블 생성
```SQL
CREATE TABLE table_name (
    column1 datatype,
    ...
    columnN datatype
);
```

- 필드 규칙

| 키워드         | 제약조건                   |
|-------------|------------------------|
| PRIMARY KEY | 기본 키 (중복 불가, NULL 불가)  |
| UNIQUE      | 고유 키 (중복 불가, NULL 허용)  |
| FOREIGN KEY | 외래 키 (다른 테이블의 기본 키 참조) |
| DEFAULT     | 기본값 설정                 |
| NOT NULL    | NULL 값 불가              |

- 테이블의 구조 조회
```SQL
DESCRIBE table_name;
DESC table_name;
```

- 데이터베이스에 속한 전체 테이블 조회
```SQL
SHOW TABLES;
SHOW TABLES FROM database_name;
```

#### 예시
- 테이블 생성 #1
  - PRIMARY KEY, NOT NULL, UNIQUE, DEFAULT 등의 제약조건 사용 
```SQL
CREATE TABLE users (
    user_id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE,
    birthdate DATE,
    registration_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

- 테이블 생성 #2
  - FOREIGN KEY 제약조건 사용
```SQL
CREATE TABLE posts (
    post_id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT,
    title VARCHAR(50) NOT NULL,
    content VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
); 
```

- 테이블 생성 #3
  - PRIMARY KEY, FOREIGN KEY, UNIQUE 제약조건 사용
```SQL
CREATE TABLE tests (
    post_id INT AUTO_INCREMENT,
    user_id INT,
    title VARCHAR(50) NOT NULL,
    content VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (post_id),
    CONSTRAINT FK_user_id FOREIGN KEY (user_id) REFERENCES users(user_id),
    CONSTRAINT UQ_title UNIQUE (title)
);
```

### ALTER

#### 기본 문법

- 테이블 내용 수정
  - 새로운 필드 추가
  ```SQL
  -- ALTER TABLE 테이블_이름 ADD COLUMN 필드_이름 필드_타입 [제약 조건]
  ALTER TABLE posts ADD COLUMN new_field VARCHAR(50) NOT NULL;
  ```
  
  - 기존 필드 수정
  ```SQL
  -- ALTER TABLE 테이블_이름 CHANGE COLUMN 기존_필드_이름 새_필드_이름 필드_타입 [제약 조건]
  ALTER TABLE posts CHANGE COLUMN new_field old_field VARCHAR(30) NOT NULL;
  ```
  
  - 기존 필드 삭제
  ```SQL
  -- ALTER TABLE 테이블_이름 DROP COLUMN 필드_이름
  ALTER TABLE posts DROP COLUMN old_field;
  ```
  - 외래 키 제약 조건 추가
  ```SQL
  -- ALTER TABLE 테이블_이름 [ADD CONSTRAINT 제약_조건_이름]
  -- ADD FOREIGN KEY (필드_이름) REFERENCES 참조_테이블_이름(참조_필드)
  ALTER TABLE posts ADD FOREIGN KEY (user_id) REFERENCES users(user_id);
  ```
  
  - UNIQUE 제약 조건 추가
  ```SQL
  -- ALTER TABLE 테이블_이름 [ADD CONSTRAINT 제약_조건_이름] UNIQUE (필드_이름)
  ALTER TABLE posts ADD UNIQUE (title);
  ```
  
  - NOT NULL 제약 조건 추가
  ```SQL
  -- ALTER TABLE 테이블_이름 MODIFY 필드_이름 필드_타입 NOT NULL
  ALTER TABLE users MODIFY email VARCHAR(100) NOT NULL;
  ```

  - 기본 키 설정(PRIMARY KEY로 사용 중인 필드가 있을 경우, 다른 필드로 변경 후 적용 가능)
  ```SQL
  -- ALTER TABLE 테이블_이름 ADD PRIMARY KEY (필드_이름)
  ALTER TABLE posts ADD PRIMARY KEY (post_id);
  ```
  
### DROP

#### 기본 문법
- 데이터베이스 삭제
```SQL
DROP DATABASE database_name;
```

- 테이블 삭제
```SQL
DROP TABLE table_name;
```

### TRUNCATE
#### 기본 문법
- 테이블 구조를 유지한 채로 테이블의 모든 레코드를 삭제
```SQL
TRUNCATE TABLE table_name;
```

## 데이터 조작 언어(DML)

| 종류     | 설명     |
|--------|--------|
| SELECT | 데이터 조회 |
| INSERT | 데이터 삽입 |
| UPDATE | 데이터 갱신 |
| DELETE | 데이터 삭제 |

### INSERT

#### 기본 문법

```SQL
INSERT INTO table_name (column1, column2, ..., columnN) VALUES
(value1, value2, ..., valueN),
...,
(value1, value2, ..., valueN);
```

#### 예시
- 데이터 삽입 #1
```SQL
INSERT INTO users (username, email, birthdate) VALUES
    ('kim', 'kim@example.com', '1996-05-15');

INSERT INTO users (username, email, birthdate) VALUES
    ('lee', 'lee@example.com', '1994-03-22'),
    ('park', 'park@example.com', '1988-07-11'),
    ('choi', 'choi@example.com', '2000-01-30'),
    ('jung', 'jung@example.com', '1992-12-05');
```

- 데이터 삽입 #2
```SQL
INSERT INTO posts (user_id, title, content) VALUES (1, 'Hi', 'Hello');
```

- 무결성 제약 조건을 위배하는 경우, INSERT 문은 실행되지 않음

### UPDATE
#### 기본 문법
- 데이터 갱신
```SQL
UPDATE table_name
SET column1 = value1, column2 = value2, ...
WHERE condition;
```

#### 예시
- 데이터 갱신 #1
```SQL
UPDATE users
    SET email = 'kim_new@example.com'
    WHERE username = 'kim';
```

- 데이터 갱신 #2
```SQL
UPDATE posts
    SET title = 'Updated Title'
    WHERE post_id > 5;
```

### DELETE
#### 기본 문법
- 데이터 삭제
```SQL
DELETE FROM table_name
WHERE condition;
```

#### 예시
- 데이터 삭제 #1
```SQL
UPDATE posts
    SET title = 'Updated Title'
    WHERE post_id > 5;
```

### 외래 키 제약 조건
- 외래 키 제약 조건이 설정된 필드를 참조하는 레코드가 존재하는 경우, 해당 레코드를 삭제하거나 참조 무결성을 위배하는 갱신 작업이 불가능함

| 제약 조건       | 설명                         |
|-------------|----------------------------|
| CASCADE     | 참조하는 데이터도 함께 수정/삭제         |
| SET NULL    | 참조하는 데이터를 NULL로 설정         |
| SET DEFAULT | 참조하는 데이터를 미리 지정한 기본값으로 설정  |
| RESTRICT    | 수정/삭제 연산 자체를 거부            |
| NO ACTION   | 참조 무결성 위배 시 아무 작업도 수행하지 않음 |

### SELECT
#### 기본 문법

- 기본 조회
  - GROUP BY: 특정 필드를 기준으로 레코드를 그룹화
  - HAVING: 그룹화된 결과에 대한 조건 지정
  - ORDER BY: 조회된 레코드를 특정 필드를 기준으로 정렬
  - LIMIT: 조회할 레코드의 개수 제한
```SQL
SELECT column1, column2, ...
FROM table_name
WHERE condition;
GROUP BY column
HAVING condition
ORDER BY column [ASC|DESC];
LIMIT number;
```

- 패턴 검색과 연산/집계 함수

| 함수      | 설명              |
|---------|-----------------|
| COUNT() | 조회한 레코드의 개수 반환  |
| SUM()   | 조회한 레코드의 합계 반환  |
| AVG()   | 조회한 레코드의 평균 반환  |
| MAX()   | 조회한 레코드의 최대값 반환 |
| MIN()   | 조회한 레코드의 최소값 반환 |



#### 예시
- 기본 조회
  - 삽입된 레코드 조회(1): 정확하게 일치하는 레코드 조회
    ```SQL
    SELECT first_name, last_name, major
        FROM students
        WHERE major = 'Computer Science';
    ```
  - 삽입된 레코드 조회(2)
    ```SQL
    SELECT first_name, last_name, age
        FROM students
        WHERE age >= 21;
    ```
- 패턴 검색과 연산/집계 함수
  - LIKE를 활용한 레코드 조회(1)
  ```SQL
  SELECT first_name, last_name, major
    FROM students
    WHERE major LIKE '%Science%';
  ```
  - LIKE를 활용한 레코드 조회(2)
  ```SQL
  SELECT first_name, last_name, major
    FROM students
    WHERE major LIKE '_a%';
  ```
  - 연산/집계를 활용한 레코드 조회
  ```SQL
  SELECT COUNT(*), AVG(gpa), MAX(gpa), MIN(gpa) FROM students
  ```
- GROUP BY
  - 그룹화된 데이터에서의 레코드 조회(1)
  ```SQL
    SELECT major, COUNT(*) AS student_count
        FROM students
        GROUP BY major;
  ```
  - 그룹화된 데이터에서의 레코드 조회(2)
  ```SQL
  SELECT age, COUNT(*) AS student_count
      FROM students
      GROUP BY age;
  ```
  - 그룹화된 데이터에서의 레코드 조회(3)
  ```SQL
  SELECT major, AVG(gpa)
      FROM students
      GROUP BY major;
  ```
  - 그룹화된 데이터에서의 레코드 조회(4)
  ```SQL
  SELECT major, AVG(age) 
      FROM students
      GROUP BY major;
  ```
- HAVING
  - 그룹화된 결과에 대한 조건 적용(1)
  ```SQL
  SELECT major, AVG(gpa)
    FROM students
    GROUP BY major
    HAVING AVG(gpa) >= 3.6;
  ```
  
  - 그룹화된 결과에 대한 조건 적용(2)
  ```SQL
  SELECT major, AVG(age)
    FROM students
    GROUP BY major
    HAVING AVG(age) >= 21;
  ```
- ORDER BY
  - 정렬된 레코드 조회
  ```SQL
  SELECT first_name, last_name, gpa
    FROM students
    ORDER BY gpa DESC;

  SELECT first_name, last_name, major
    FROM students
    ORDER BY last_name ASC;

  SELECT first_name, last_name, enrollment_date
    FROM students
    ORDER BY enrollment_date ASC;
  ```
## 트랜잭션 제어 언어(TCL)

### 기본 문법

| 종류      | 설명                          |
|---------|-----------------------------|
| COMMIT  | 데이터베이스에 작업 반영(트랜잭션 확정)      |
| ROLLBACK | 작업 이전의 상태로 되돌림(트랜잭션 취소)     |
| SAVEPOINT | 롤백의 기준점 설정(트랜잭션 내 특정 지점 설정) |

### 예시
- ROLLBACK
```SQL
START TRANSACTION; // MySQL에서 Auto-commit 모드를 비활성화하는 명령어
// AUTO COMMIT 모드가 비활성화되면, 모든 DML 문은 명시적으로 COMMIT 혹은 ROLLBACK이 실행될 때까지 임시 상태로 유지됨
// 따라서 트랜잭션이 확정되기 전까지는 데이터베이스에 영구적으로 반영되지 않음
// 트랜젝션이 중간에 중단되더라도, COMMIT이 실행되기 전까지는 데이터베이스의 무결성/원자성이 유지됨

-- 시점 ➊: 2개의 레코드 확인
SELECT * FROM accounts;
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;

-- 시점 ➋: account_id가 1인 레코드의 balance가 100 감소되었음을 확인
SELECT * FROM accounts;
ROLLBACK;

-- 시점 ➌
SELECT * FROM accounts;
```
- SAVEPOINT and ROLLBACK
```SQL
START TRANSACTION;

-- 세이브포인트 생성 ➊
SAVEPOINT sp1;
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;

-- 세이브포인트 생성 ➋
SAVEPOINT sp2;
UPDATE accounts SET account_name = 'new_Kim' WHERE account_id = 1;
UPDATE accounts SET account_name = 'new_Lee' WHERE account_id = 2;

-- 세이브포인트 생성 ➌
SAVEPOINT sp3;
SELECT * FROM accounts;

-- 특정 세이브포인트로 롤백
ROLLBACK TO SAVEPOINT sp2;
ROLLBACK TO SAVEPOINT sp1;
COMMIT;
```

## DCL

| 종류     | 설명           |
|--------|--------------|
| GRANT  | 사용자에게 권한 부여  |
| REVOKE | 사용자로부터 권한 회수 |