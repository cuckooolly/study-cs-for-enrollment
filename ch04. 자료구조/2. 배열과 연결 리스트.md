# 배열과 연결 리스트

## 배열

- 배열
- ![](https://csnote.net/assets/img/ds/array.png)
  - 일정한 메모리 공간을 차지하는 여러 요소들이 순차적으로 나열된 자료구조
  - 각 요소에는 0부터 시작하는 고유 순서번호인 인덱스가 매겨짐
- 인덱스
  - 배열에서 특정 요소를 참조하기 위한 0부터 시작하는 정수 값
  - 배열 시작 위치로부터 요소까지의 거리를 나타냄
- 정적 배열
  - 프로그램을 실행하기 전에 크기가 고정된 배열
  - 초기화 시 배열의 크기를 지정
- 동적 배열
  - 크기를 동적으로 조장할 수 있는 배열
  - 벡터라는 이름으로 지칭하기도 함
  
## 연결 리스트

- 연결 리스트
- ![](https://csnote.net/assets/img/ds/linked_list.png)
- ![](https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nhzxfBmkpRzqeZ57i0DahA.gif)
  - 각 노드가 데이터와 다음 노트에 대한 포인터를 가지는 자료구조
- 노드
  - 헤드 노드: 연결 리스트의 첫번째 노드
  - 꼬리 노드: 연결 리스트의 마지막 노드
- 종류
  - 이중 연결 리스트: 각 노드가 이전 노드에 대한 포인터를 가지는 연결리스트, 양방향 탐색이 가능
  ![](https://csnote.net/assets/img/ds/doubly_linked_list.png)
  - 원형 연결 리스트: 마지막 노드가 첫번째 노드를 가리키는 연결 리스트, 순환 구조를 가짐
  ![](https://csnote.net/assets/img/ds/doubly_linked_list.png)

## 참고자료
- https://csnote.net/
- Java로 구현하는 연결 리스트: https://medium.com/@omkarbhavare2406/linked-list-882c62f7892d
- 어떤 것이 더 유리한가? -> 대부분의 경우에서는 배열이 더 유리함
  - 배열
    - 인덱스 기반 접근이 중요할 때 (예: arr[i])
    - 정렬/이진탐색/슬라이딩 윈도우/DP 등 연속 메모리가 성능을 좌우할 때 
    - 데이터가 비교적 고정 길이거나, 늘어나도 append 중심일 때 
    - 캐시 적중률이 중요할 때(대부분의 고성능 루프)
  - 연결 리스트
    - 중간 삽입/삭제가 아주 빈번하고, 해당 위치의 포인터(이터레이터)를 이미 보유하고 있을 때 
    - 노드 이동(splice), 큐/디큐처럼 양끝 조작이 잦을 때 
    - LRU 캐시처럼 “키→노드” 맵과 함께 O(1) 재배치가 필요할 때 
    - 원형 리스트/병합 정렬(메모리 추가 없이) 등 리스트 고유 패턴이 필요할 때
